// export {selectGlossDimensions}
// export {togb4e}
// export {toExPex}

let leipzigGrammar = {
    "metadata": {
        "title": "Leipzig Glossing Grammatical Categories",
        "source": "Leipzig Glossing Rules",
        "url": "https://www.eva.mpg.de/lingua/resources/glossing-rules.php"
    },
    "categories": [
        {
            "abbreviation": "1",
            "value": "first person",
            "category": ""
        },
        {
            "abbreviation": "2",
            "value": "second person",
            "category": ""
        },
        {
            "abbreviation": "3",
            "value": "third person",
            "category": ""
        },
        {
            "abbreviation": "A",
            "value": "agent-like argument of canonical transitive verb",
            "category": ""
        },
        {
            "abbreviation": "ABL",
            "value": "ablative",
            "category": ""
        },
        {
            "abbreviation": "ABS",
            "value": "absolutive",
            "category": ""
        },
        {
            "abbreviation": "ACC",
            "value": "accusative",
            "category": ""
        },
        {
            "abbreviation": "ADJ",
            "value": "adjective",
            "category": ""
        },
        {
            "abbreviation": "ADV",
            "value": "adverb(ial)",
            "category": ""
        },
        {
            "abbreviation": "AGR",
            "value": "agreement",
            "category": ""
        },
        {
            "abbreviation": "ALL",
            "value": "allative",
            "category": ""
        },
        {
            "abbreviation": "ANTIP",
            "value": "antipassive",
            "category": ""
        },
        {
            "abbreviation": "APPL",
            "value": "applicative",
            "category": ""
        },
        {
            "abbreviation": "ART",
            "value": "article",
            "category": ""
        },
        {
            "abbreviation": "AUX",
            "value": "auxiliary",
            "category": ""
        },
        {
            "abbreviation": "BEN",
            "value": "benefactive",
            "category": ""
        },
        {
            "abbreviation": "CAUS",
            "value": "causative",
            "category": ""
        },
        {
            "abbreviation": "CLF",
            "value": "classifier",
            "category": ""
        },
        {
            "abbreviation": "COM",
            "value": "comitative",
            "category": ""
        },
        {
            "abbreviation": "COMP",
            "value": "complementizer",
            "category": ""
        },
        {
            "abbreviation": "COMPL",
            "value": "completive",
            "category": ""
        },
        {
            "abbreviation": "COND",
            "value": "conditional",
            "category": ""
        },
        {
            "abbreviation": "COP",
            "value": "copula",
            "category": ""
        },
        {
            "abbreviation": "CVB",
            "value": "converb",
            "category": ""
        },
        {
            "abbreviation": "DAT",
            "value": "dative",
            "category": ""
        },
        {
            "abbreviation": "DECL",
            "value": "declarative",
            "category": ""
        },
        {
            "abbreviation": "DEF",
            "value": "definite",
            "category": ""
        },
        {
            "abbreviation": "DEM",
            "value": "demonstrative",
            "category": ""
        },
        {
            "abbreviation": "DET",
            "value": "determiner",
            "category": ""
        },
        {
            "abbreviation": "DIST",
            "value": "distal",
            "category": ""
        },
        {
            "abbreviation": "DISTR",
            "value": "distributive",
            "category": ""
        },
        {
            "abbreviation": "DU",
            "value": "dual",
            "category": ""
        },
        {
            "abbreviation": "DUR",
            "value": "durative",
            "category": ""
        },
        {
            "abbreviation": "ERG",
            "value": "ergative",
            "category": ""
        },
        {
            "abbreviation": "EXCL",
            "value": "exclusive",
            "category": ""
        },
        {
            "abbreviation": "F",
            "value": "feminine",
            "category": ""
        },
        {
            "abbreviation": "FOC",
            "value": "focus",
            "category": ""
        },
        {
            "abbreviation": "FUT",
            "value": "future",
            "category": ""
        },
        {
            "abbreviation": "GEN",
            "value": "genitive",
            "category": ""
        },
        {
            "abbreviation": "IMP",
            "value": "imperative",
            "category": ""
        },
        {
            "abbreviation": "INCL",
            "value": "inclusive",
            "category": ""
        },
        {
            "abbreviation": "IND",
            "value": "indicative",
            "category": ""
        },
        {
            "abbreviation": "INDF",
            "value": "indefinite",
            "category": ""
        },
        {
            "abbreviation": "INF",
            "value": "infinitive",
            "category": ""
        },
        {
            "abbreviation": "INS",
            "value": "instrumental",
            "category": ""
        },
        {
            "abbreviation": "INTR",
            "value": "intransitive",
            "category": ""
        },
        {
            "abbreviation": "IPFV",
            "value": "imperfective",
            "category": ""
        },
        {
            "abbreviation": "IRR",
            "value": "irrealis",
            "category": ""
        },
        {
            "abbreviation": "LOC",
            "value": "locative",
            "category": ""
        },
        {
            "abbreviation": "M",
            "value": "masculine",
            "category": ""
        },
        {
            "abbreviation": "N",
            "value": "neuter",
            "category": ""
        },
        {
            "abbreviation": "N-",
            "value": "non- (e.g. NSG nonsingular, NPST nonpast)",
            "category": ""
        },
        {
            "abbreviation": "NEG",
            "value": "negation, negative",
            "category": ""
        },
        {
            "abbreviation": "NMLZ",
            "value": "nominalizer/nominalization",
            "category": ""
        },
        {
            "abbreviation": "NOM",
            "value": "nominative",
            "category": ""
        },
        {
            "abbreviation": "OBJ",
            "value": "object",
            "category": ""
        },
        {
            "abbreviation": "OBL",
            "value": "oblique",
            "category": ""
        },
        {
            "abbreviation": "P",
            "value": "patient-like argument of canonical transitive verb",
            "category": ""
        },
        {
            "abbreviation": "PASS",
            "value": "passive",
            "category": ""
        },
        {
            "abbreviation": "PFV",
            "value": "perfective",
            "category": ""
        },
        {
            "abbreviation": "PL",
            "value": "plural",
            "category": ""
        },
        {
            "abbreviation": "POSS",
            "value": "possessive",
            "category": ""
        },
        {
            "abbreviation": "PRED",
            "value": "predicative",
            "category": ""
        },
        {
            "abbreviation": "PRF",
            "value": "perfect",
            "category": ""
        },
        {
            "abbreviation": "PRS",
            "value": "present",
            "category": ""
        },
        {
            "abbreviation": "PROG",
            "value": "progressive",
            "category": ""
        },
        {
            "abbreviation": "PROH",
            "value": "prohibitive",
            "category": ""
        },
        {
            "abbreviation": "PROX",
            "value": "proximal/proximate",
            "category": ""
        },
        {
            "abbreviation": "PST",
            "value": "past",
            "category": ""
        },
        {
            "abbreviation": "PTCP",
            "value": "participle",
            "category": ""
        },
        {
            "abbreviation": "PURP",
            "value": "purposive",
            "category": ""
        },
        {
            "abbreviation": "Q",
            "value": "question particle/marker",
            "category": ""
        },
        {
            "abbreviation": "QUOT",
            "value": "quotative",
            "category": ""
        },
        {
            "abbreviation": "RECP",
            "value": "reciprocal",
            "category": ""
        },
        {
            "abbreviation": "REFL",
            "value": "reflexive",
            "category": ""
        },
        {
            "abbreviation": "REL",
            "value": "relative",
            "category": ""
        },
        {
            "abbreviation": "RES",
            "value": "resultative",
            "category": ""
        },
        {
            "abbreviation": "S",
            "value": "single argument of canonical intransitive verb",
            "category": ""
        },
        {
            "abbreviation": "SBJ",
            "value": "subject",
            "category": ""
        },
        {
            "abbreviation": "SBJV",
            "value": "subjunctive",
            "category": ""
        },
        {
            "abbreviation": "SG",
            "value": "singular",
            "category": ""
        },
        {
            "abbreviation": "TOP",
            "value": "topic",
            "category": ""
        },
        {
            "abbreviation": "TR",
            "value": "transitive",
            "category": ""
        },
        {
            "abbreviation": "VOC",
            "value": "vocative",
            "category": ""
        }
    ]
}

// let leipzigGrammar = await fetch("./leipzig-grammar.json")
// //let leipzig = await fetch("https://raw.githubusercontent.com/doclingjs/parse-leipzig/main/leipzig-grammar.json")
// .then(response => response.json())



let selectGlossDimensions = (text, dimensions = ["morph-txt", "morph-gls"]) => {
    // go through each sentence, take the whole object save for the morph things not desired
    let reducedSentences = []
    text.sentences.forEach(sentence => {
        let reducedSentence = {
            "transcription": sentence.transcription,
            // just using the first one
            "translation": sentence.translations[0]["translation"],
            "word_breakdown": "",
            "notes": sentence.notes
        }
        let words = sentence.words
        reducedMorphs = []
        words.forEach(word => {
            if (dimensions.includes("word_breakdown")) {
                reducedSentence["word_breakdown"] += word["word_breakdown"] + " "
            }
            // we don't want anything at the word level for this, just morphs
            word.morphs.forEach(morph => {
                let newMorphDict = {} // change from "Dict" at some point--python terminology holdover
                dimensions.forEach(dimension => {
                    if (morph[dimension]) {
                        newMorphDict[dimension] = morph[dimension]
                    }
                    else {
                        newMorphDict[dimension] = "{}"
                    }
                })
                reducedMorphs.push(newMorphDict)
            })
        })
        reducedSentence["morphs"] = reducedMorphs
        reducedSentences.push(reducedSentence)
    })
    return reducedSentences
}

let getGlosses = morphs => {
    return morphs.map(morph => {
        let gloss
        if (document.querySelector("#underscores").checked) {
            gloss = morph["morph-gls"].replace(/ /g, "\\_")
        }
        else {
            if (morph["morph-gls"].includes(" ")) {
                gloss = `{${morph["morph-gls"]}}`
            }
            else {
                gloss = morph["morph-gls"]
            }
        }
        if (leipzigGrammar.categories.some(cat => cat.abbreviation.toLowerCase() == gloss.toLowerCase())) {
            gloss = `\\textsc{${gloss.toLowerCase()}}`
        }
        else {
            if (leipzigGrammar.categories.some(cat => cat.value.toLowerCase() == gloss.toLowerCase())) {
                gloss = `\\textsc{${leipzigGrammar.categories.find(cat => cat.value.toLowerCase() == gloss.toLowerCase()).abbreviation.toLowerCase()}}`
            }
            if (gloss.split(".").some(glossPart => leipzigGrammar.categories.some(cat => cat.abbreviation.toLowerCase() == glossPart.toLowerCase()))) {
                let newGloss = []
                gloss.split(".").forEach(glossPart => {
                    if (leipzigGrammar.categories.some(cat => cat.abbreviation.toLowerCase() == glossPart.toLowerCase())) {
                        newGloss.push(`\\textsc{${glossPart.toLowerCase()}}`)
                    }
                    else {
                        if (leipzigGrammar.categories.some(cat => cat.value.toLowerCase() == gloss.toLowerCase())) {
                            newGloss.push(`\\textsc{${leipzigGrammar.categories.find(cat => cat.value.toLowerCase() == gloss.toLowerCase()).abbreviation.toLowerCase()}}`)
                        }
                        else {
                            newGloss.push(glossPart)
                        }
                    }
                })
                gloss = newGloss.join(".")
            }
        }
        return gloss
    })
}

let togb4e = text => {
    let newSentences = []
    // this parses the input as text
    let oldSentences = selectGlossDimensions(JSON.parse(text))
    oldSentences.forEach(sentence => {
        let forms = sentence.morphs.map(morph => morph["morph-txt"])
        let glosses = getGlosses(sentence.morphs)
        let translation = sentence.translation
        let newSentence =
            `
\\begin{exe}
\\ex
\\gll ${forms.join(" ")} \\\\
${glosses.join(" ")} \\\\
\\glt ${translation}
\\end{exe}
`
        newSentences.push(newSentence)
    })
    let texGloss = newSentences.join("\n")
    document.querySelector("#latex").value = texGloss
    return texGloss
}

let rendergb4eFromFile = text => {
    let reader = new FileReader()
    reader.addEventListener("load", () => {
        document.querySelector("#latex").value = togb4e(reader.result)
    }, false)
    reader.readAsText(text)
}

let rendergb4eFromRawJSON = text => {
    document.querySelector("#latex").value = togb4e(text)
}


let toExPex = (text, dimensions=["morph-txt", "morph-gls"]) => {
    let newSentences = []
    // this parses the input as text
    let oldSentences = selectGlossDimensions(JSON.parse(text), dimensions)
    oldSentences.forEach(sentence => {
        let newSentence = `\\pex\n\\begingl\n\\glpreamble ${sentence.transcription} //\n`
        if (dimensions.includes("word_breakdown")) {
            newSentence += `\\glpreamble ${sentence.word_breakdown} //\n`
        }
        let forms = sentence.morphs.map(morph => morph["morph-txt"])
        newSentence += `\\gla ${forms.join(" ")} //\n`
        if (dimensions.includes("morph-cf")) {
            let morphCF = sentence.morphs.map(morph => morph["morph-cf"])
            newSentence += `\\glb ${morphCF.join(" ")} //\n`
        }
        let glosses = getGlosses(sentence.morphs)
        newSentence += `\\glb ${glosses.join(" ")} //\n`
        if (dimensions.includes("morph-msa")) {
            let morphMSA = sentence.morphs.map(morph => morph["morph-msa"])
            newSentence += `\\glc ${morphMSA.join(" ")} //\n`
        }
        if (dimensions.includes("morph_type")) {
            let morphType = sentence.morphs.map(morph => morph["morph_type"])
            newSentence += `\\glc ${morphType.join(" ")} //\n`
        }
        newSentence += `\\glft ${sentence.translation}\n`
        
        if (dimensions.includes("notes") && sentence.notes.length) {
            newSentence += `\\footnotesize\n`
            sentence.notes.forEach(note => {
                newSentence += `\\\\ ${note}\n`
            })
        }
        newSentence += `//\n\\endgl\n\\xe`
        newSentences.push(newSentence)
    })
    let texGloss = newSentences.join("\n\n")
    document.querySelector("#latex").value = texGloss
    return texGloss
}

let renderExPexFromFile = (text, dimensions) => {
    let reader = new FileReader()
    reader.addEventListener("load", () => {
        document.querySelector("#latex").value = toExPex(reader.result, dimensions)
    }, false)
    reader.readAsText(text)
}

let renderExPexFromRawJSON = (text, dimensions) => {
    document.querySelector("#latex").value = toExPex(text, dimensions)
}